<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Maze Game</title>
<style>
    body {
        font-family: Arial, sans-serif;
        text-align: center;
        background-color: #f0f0f0;
        margin: 0;
        padding: 20px;
    }
    .maze-container {
        display: flex;
        justify-content: center;
    }
    .maze {
        display: grid;
        grid-template-columns: repeat(15, 30px);
        grid-template-rows: repeat(15, 30px);
        gap: 1px;
        border: 2px solid #333;
    }
    .cell {
        background-color: #c0c0c0;
        border: 2px solid #606060;
    }
    .wall {
        background-color: #606060;
    }
    .exit {
        background-color: #00cc00;
        background-image: url('https://emojicdn.elk.sh/ðŸšª');
        background-size: cover;
    }
    .player {
        background-color: #ffcc00;
        background-image: url('https://emojicdn.elk.sh/ðŸ¤–');
        background-size: cover;
    }
    .obstacle {
        background-color: #ff0000;
        background-image: url('https://emojicdn.elk.sh/ðŸš§');
        background-size: cover;
    }
    h1 {
        color: #333;
    }
    p {
        color: #666;
        margin-bottom: 20px;
    }
</style>
</head>
<body>
<h1>Maze Game</h1>
<p>Use arrow keys to navigate. Avoid moving obstacles and find the exit!</p>
<div class="maze-container">
    <div class="maze" id="maze"></div>
</div>
<script>
    const ROWS = 15;
    const COLS = 15;
    const NUM_OBSTACLES = 5;
    const OBSTACLE_INTERVAL = 1000;

    let maze = [];
    let playerPos = { row: 0, col: 0 };
    let obstacles = [];

    function createMaze() {
        let mazeDiv = document.getElementById("maze");

        // Initialize maze grid with walls
        for (let i = 0; i < ROWS; i++) {
            let row = [];
            for (let j = 0; j < COLS; j++) {
                let cellDiv = document.createElement("div");
                cellDiv.classList.add("cell", "wall");
                mazeDiv.appendChild(cellDiv);
                row.push(cellDiv);
            }
            maze.push(row);
        }

        // Generate maze using depth-first search with backtracking
        let stack = [];
        let startX = Math.floor(Math.random() * ROWS);
        let startY = Math.floor(Math.random() * COLS);
        stack.push({ row: startX, col: startY });

        while (stack.length > 0) {
            let current = stack.pop();
            let row = current.row;
            let col = current.col;
            maze[row][col].classList.remove("wall");

            let directions = [{ row: row - 1, col: col }, { row: row + 1, col: col }, { row: row, col: col - 1 }, { row: row, col: col + 1 }];
            directions = directions.sort(() => Math.random() - 0.5);

            for (let dir of directions) {
                let newRow = dir.row;
                let newCol = dir.col;
                if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS && maze[newRow][newCol].classList.contains("wall")) {
                    stack.push({ row: newRow, col: newCol });
                }
            }
        }

        // Set exit
        maze[ROWS - 1][COLS - 1].classList.add("exit");

        // Set player position
        maze[playerPos.row][playerPos.col].classList.add("player");

        // Create obstacles
        for (let i = 0; i < NUM_OBSTACLES; i++) {
            let obstacle = { row: Math.floor(Math.random() * ROWS), col: Math.floor(Math.random() * COLS) };
            obstacles.push(obstacle);
            maze[obstacle.row][obstacle.col].classList.add("obstacle");
        }
    }

    function moveObstacles() {
        for (let obstacle of obstacles) {
            let newRow = obstacle.row;
            let newCol = obstacle.col;
            let directions = ["up", "down", "left", "right"];
            let direction = directions[Math.floor(Math.random() * directions.length)];

            switch (direction) {
                case "up":
                    newRow--;
                    break;
                case "down":
                    newRow++;
                    break;
                case "left":
                    newCol--;
                    break;
                case "right":
                    newCol++;
                    break;
            }

            if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS &&
                !maze[newRow][newCol].classList.contains("wall") &&
                !maze[newRow][newCol].classList.contains("obstacle")) {
                maze[obstacle.row][obstacle.col].classList.remove("obstacle");
                obstacle.row = newRow;
                obstacle.col = newCol;
                maze[obstacle.row][obstacle.col].classList.add("obstacle");
            }
        }
    }

    function movePlayer(direction) {
        let newRow = playerPos.row;
        let newCol = playerPos.col;

        switch (direction) {
            case "up":
                newRow--;
                break;
            case "down":
                newRow++;
                break;
            case "left":
                newCol--;
                break;
            case "right":
                newCol++;
                break;
        }

        if (newRow >= 0 && newRow < ROWS && newCol >= 0 && newCol < COLS &&
            !maze[newRow][newCol].classList.contains("wall") &&
            !maze[newRow][newCol].classList.contains("obstacle")) {
            maze[playerPos.row][playerPos.col].classList.remove("player");
            playerPos.row = newRow;
            playerPos.col = newCol;
            maze[playerPos.row][playerPos.col].classList.add("player");

            if (maze[playerPos.row][playerPos.col].classList.contains("exit")) {
                alert("Congratulations! You found the exit!");
                resetGame();
            }
        }
    }

    function resetGame() {
        maze = [];
        playerPos = { row: 0, col: 0 };
        obstacles = [];
        document.getElementById("maze").innerHTML = "";
        createMaze();
    }

    document.addEventListener("keydown", function(event) {
        switch (event.key) {
            case "ArrowUp":
                movePlayer("up");
                break;
            case "ArrowDown":
                movePlayer("down");
                break;
            case "ArrowLeft":
                movePlayer("left");
                break;
            case "ArrowRight":
                movePlayer("right");
                break;
        }
    });

    createMaze();
    setInterval(moveObstacles, OBSTACLE_INTERVAL);
</script>
</body>
</html>
